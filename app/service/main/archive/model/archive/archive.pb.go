// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: app/service/main/archive/model/archive/archive.proto

package archive

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	go_common_library_time "go-common/library/time"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Archive3 struct {
	Aid                  int64                       `protobuf:"varint,1,opt,name=Aid,proto3" json:"aid"`
	Videos               int64                       `protobuf:"varint,2,opt,name=Videos,proto3" json:"videos"`
	TypeID               int32                       `protobuf:"varint,3,opt,name=TypeID,proto3" json:"tid"`
	TypeName             string                      `protobuf:"bytes,4,opt,name=TypeName,proto3" json:"tname"`
	Copyright            int32                       `protobuf:"varint,5,opt,name=Copyright,proto3" json:"copyright"`
	Pic                  string                      `protobuf:"bytes,6,opt,name=Pic,proto3" json:"pic"`
	Title                string                      `protobuf:"bytes,7,opt,name=Title,proto3" json:"title"`
	PubDate              go_common_library_time.Time `protobuf:"varint,8,opt,name=PubDate,proto3,casttype=go-common/library/time.Time" json:"pubdate"`
	Ctime                go_common_library_time.Time `protobuf:"varint,9,opt,name=Ctime,proto3,casttype=go-common/library/time.Time" json:"ctime"`
	Desc                 string                      `protobuf:"bytes,10,opt,name=Desc,proto3" json:"desc"`
	State                int32                       `protobuf:"varint,11,opt,name=State,proto3" json:"state"`
	Access               int32                       `protobuf:"varint,12,opt,name=Access,proto3" json:"access,omitempty"`
	Attribute            int32                       `protobuf:"varint,13,opt,name=Attribute,proto3" json:"attribute,omitempty"`
	Tag                  string                      `protobuf:"bytes,14,opt,name=Tag,proto3" json:"-"`
	Tags                 []string                    `protobuf:"bytes,15,rep,name=Tags,proto3" json:"tags,omitempty"`
	Duration             int64                       `protobuf:"varint,16,opt,name=Duration,proto3" json:"duration"`
	MissionID            int64                       `protobuf:"varint,17,opt,name=MissionID,proto3" json:"mission_id,omitempty"`
	OrderID              int64                       `protobuf:"varint,18,opt,name=OrderID,proto3" json:"order_id,omitempty"`
	RedirectURL          string                      `protobuf:"bytes,19,opt,name=RedirectURL,proto3" json:"redirect_url,omitempty"`
	Forward              int64                       `protobuf:"varint,20,opt,name=Forward,proto3" json:"forward,omitempty"`
	Rights               Rights3                     `protobuf:"bytes,21,opt,name=Rights,proto3" json:"rights"`
	Author               Author3                     `protobuf:"bytes,22,opt,name=Author,proto3" json:"owner"`
	Stat                 Stat3                       `protobuf:"bytes,23,opt,name=Stat,proto3" json:"stat"`
	ReportResult         string                      `protobuf:"bytes,24,opt,name=ReportResult,proto3" json:"report_result,omitempty"`
	Dynamic              string                      `protobuf:"bytes,25,opt,name=Dynamic,proto3" json:"dynamic"`
	FirstCid             int64                       `protobuf:"varint,26,opt,name=FirstCid,proto3" json:"cid,omitempty"`
	Dimension            Dimension                   `protobuf:"bytes,27,opt,name=Dimension,proto3" json:"dimension,omitempty"`
	StaffInfo            []*StaffInfo                `protobuf:"bytes,28,rep,name=StaffInfo,proto3" json:"-"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *Archive3) Reset()         { *m = Archive3{} }
func (m *Archive3) String() string { return proto.CompactTextString(m) }
func (*Archive3) ProtoMessage()    {}
func (*Archive3) Descriptor() ([]byte, []int) {
	return fileDescriptor_4d6cd72ef61298a2, []int{0}
}
func (m *Archive3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Archive3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Archive3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Archive3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Archive3.Merge(m, src)
}
func (m *Archive3) XXX_Size() int {
	return m.Size()
}
func (m *Archive3) XXX_DiscardUnknown() {
	xxx_messageInfo_Archive3.DiscardUnknown(m)
}

var xxx_messageInfo_Archive3 proto.InternalMessageInfo

type StaffInfo struct {
	Mid                  int64    `protobuf:"varint,1,opt,name=Mid,proto3" json:"mid"`
	Title                string   `protobuf:"bytes,2,opt,name=Title,proto3" json:"title"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StaffInfo) Reset()         { *m = StaffInfo{} }
func (m *StaffInfo) String() string { return proto.CompactTextString(m) }
func (*StaffInfo) ProtoMessage()    {}
func (*StaffInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4d6cd72ef61298a2, []int{1}
}
func (m *StaffInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StaffInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StaffInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StaffInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StaffInfo.Merge(m, src)
}
func (m *StaffInfo) XXX_Size() int {
	return m.Size()
}
func (m *StaffInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_StaffInfo.DiscardUnknown(m)
}

var xxx_messageInfo_StaffInfo proto.InternalMessageInfo

type Dimension struct {
	Width                int64    `protobuf:"varint,1,opt,name=Width,proto3" json:"width"`
	Height               int64    `protobuf:"varint,2,opt,name=Height,proto3" json:"height"`
	Rotate               int64    `protobuf:"varint,3,opt,name=Rotate,proto3" json:"rotate"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Dimension) Reset()         { *m = Dimension{} }
func (m *Dimension) String() string { return proto.CompactTextString(m) }
func (*Dimension) ProtoMessage()    {}
func (*Dimension) Descriptor() ([]byte, []int) {
	return fileDescriptor_4d6cd72ef61298a2, []int{2}
}
func (m *Dimension) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Dimension) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Dimension.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Dimension) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Dimension.Merge(m, src)
}
func (m *Dimension) XXX_Size() int {
	return m.Size()
}
func (m *Dimension) XXX_DiscardUnknown() {
	xxx_messageInfo_Dimension.DiscardUnknown(m)
}

var xxx_messageInfo_Dimension proto.InternalMessageInfo

type Rights3 struct {
	Bp                   int32    `protobuf:"varint,1,opt,name=Bp,proto3" json:"bp"`
	Elec                 int32    `protobuf:"varint,2,opt,name=Elec,proto3" json:"elec"`
	Download             int32    `protobuf:"varint,3,opt,name=Download,proto3" json:"download"`
	Movie                int32    `protobuf:"varint,4,opt,name=Movie,proto3" json:"movie"`
	Pay                  int32    `protobuf:"varint,5,opt,name=Pay,proto3" json:"pay"`
	HD5                  int32    `protobuf:"varint,6,opt,name=HD5,proto3" json:"hd5"`
	NoReprint            int32    `protobuf:"varint,7,opt,name=NoReprint,proto3" json:"no_reprint"`
	Autoplay             int32    `protobuf:"varint,8,opt,name=Autoplay,proto3" json:"autoplay"`
	UGCPay               int32    `protobuf:"varint,9,opt,name=UGCPay,proto3" json:"ugc_pay"`
	IsCooperation        int32    `protobuf:"varint,10,opt,name=IsCooperation,proto3" json:"is_cooperation"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Rights3) Reset()         { *m = Rights3{} }
func (m *Rights3) String() string { return proto.CompactTextString(m) }
func (*Rights3) ProtoMessage()    {}
func (*Rights3) Descriptor() ([]byte, []int) {
	return fileDescriptor_4d6cd72ef61298a2, []int{3}
}
func (m *Rights3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Rights3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Rights3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Rights3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Rights3.Merge(m, src)
}
func (m *Rights3) XXX_Size() int {
	return m.Size()
}
func (m *Rights3) XXX_DiscardUnknown() {
	xxx_messageInfo_Rights3.DiscardUnknown(m)
}

var xxx_messageInfo_Rights3 proto.InternalMessageInfo

type Author3 struct {
	Mid                  int64    `protobuf:"varint,1,opt,name=Mid,proto3" json:"mid"`
	Name                 string   `protobuf:"bytes,2,opt,name=Name,proto3" json:"name"`
	Face                 string   `protobuf:"bytes,3,opt,name=Face,proto3" json:"face"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Author3) Reset()         { *m = Author3{} }
func (m *Author3) String() string { return proto.CompactTextString(m) }
func (*Author3) ProtoMessage()    {}
func (*Author3) Descriptor() ([]byte, []int) {
	return fileDescriptor_4d6cd72ef61298a2, []int{4}
}
func (m *Author3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Author3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Author3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Author3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Author3.Merge(m, src)
}
func (m *Author3) XXX_Size() int {
	return m.Size()
}
func (m *Author3) XXX_DiscardUnknown() {
	xxx_messageInfo_Author3.DiscardUnknown(m)
}

var xxx_messageInfo_Author3 proto.InternalMessageInfo

type Stat3 struct {
	Aid                  int64    `protobuf:"varint,1,opt,name=Aid,proto3" json:"aid"`
	View                 int32    `protobuf:"varint,2,opt,name=View,proto3" json:"view"`
	Danmaku              int32    `protobuf:"varint,3,opt,name=Danmaku,proto3" json:"danmaku"`
	Reply                int32    `protobuf:"varint,4,opt,name=Reply,proto3" json:"reply"`
	Fav                  int32    `protobuf:"varint,5,opt,name=Fav,proto3" json:"favorite"`
	Coin                 int32    `protobuf:"varint,6,opt,name=Coin,proto3" json:"coin"`
	Share                int32    `protobuf:"varint,7,opt,name=Share,proto3" json:"share"`
	NowRank              int32    `protobuf:"varint,8,opt,name=NowRank,proto3" json:"now_rank"`
	HisRank              int32    `protobuf:"varint,9,opt,name=HisRank,proto3" json:"his_rank"`
	Like                 int32    `protobuf:"varint,10,opt,name=Like,proto3" json:"like"`
	DisLike              int32    `protobuf:"varint,11,opt,name=DisLike,proto3" json:"dislike"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Stat3) Reset()         { *m = Stat3{} }
func (m *Stat3) String() string { return proto.CompactTextString(m) }
func (*Stat3) ProtoMessage()    {}
func (*Stat3) Descriptor() ([]byte, []int) {
	return fileDescriptor_4d6cd72ef61298a2, []int{5}
}
func (m *Stat3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Stat3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Stat3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Stat3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Stat3.Merge(m, src)
}
func (m *Stat3) XXX_Size() int {
	return m.Size()
}
func (m *Stat3) XXX_DiscardUnknown() {
	xxx_messageInfo_Stat3.DiscardUnknown(m)
}

var xxx_messageInfo_Stat3 proto.InternalMessageInfo

type Click3 struct {
	Aid                  int64    `protobuf:"varint,1,opt,name=Aid,proto3" json:"aid"`
	Web                  int32    `protobuf:"varint,2,opt,name=Web,proto3" json:"web"`
	Ios                  int32    `protobuf:"varint,3,opt,name=Ios,proto3" json:"ios"`
	Android              int32    `protobuf:"varint,4,opt,name=Android,proto3" json:"android"`
	H5                   int32    `protobuf:"varint,5,opt,name=H5,proto3" json:"h5"`
	Outter               int32    `protobuf:"varint,6,opt,name=Outter,proto3" json:"outter"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Click3) Reset()         { *m = Click3{} }
func (m *Click3) String() string { return proto.CompactTextString(m) }
func (*Click3) ProtoMessage()    {}
func (*Click3) Descriptor() ([]byte, []int) {
	return fileDescriptor_4d6cd72ef61298a2, []int{6}
}
func (m *Click3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Click3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Click3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Click3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Click3.Merge(m, src)
}
func (m *Click3) XXX_Size() int {
	return m.Size()
}
func (m *Click3) XXX_DiscardUnknown() {
	xxx_messageInfo_Click3.DiscardUnknown(m)
}

var xxx_messageInfo_Click3 proto.InternalMessageInfo

type AidVideos3 struct {
	Aid                  int64    `protobuf:"varint,1,opt,name=Aid,proto3" json:"aid"`
	Pages                []*Page3 `protobuf:"bytes,2,rep,name=Pages,proto3" json:"pages"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AidVideos3) Reset()         { *m = AidVideos3{} }
func (m *AidVideos3) String() string { return proto.CompactTextString(m) }
func (*AidVideos3) ProtoMessage()    {}
func (*AidVideos3) Descriptor() ([]byte, []int) {
	return fileDescriptor_4d6cd72ef61298a2, []int{7}
}
func (m *AidVideos3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AidVideos3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AidVideos3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AidVideos3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AidVideos3.Merge(m, src)
}
func (m *AidVideos3) XXX_Size() int {
	return m.Size()
}
func (m *AidVideos3) XXX_DiscardUnknown() {
	xxx_messageInfo_AidVideos3.DiscardUnknown(m)
}

var xxx_messageInfo_AidVideos3 proto.InternalMessageInfo

type View3 struct {
	*Archive3            `protobuf:"bytes,1,opt,name=Archive,proto3,embedded=Archive" json:""`
	Pages                []*Page3 `protobuf:"bytes,2,rep,name=Pages,proto3" json:"pages,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *View3) Reset()         { *m = View3{} }
func (m *View3) String() string { return proto.CompactTextString(m) }
func (*View3) ProtoMessage()    {}
func (*View3) Descriptor() ([]byte, []int) {
	return fileDescriptor_4d6cd72ef61298a2, []int{8}
}
func (m *View3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *View3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_View3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *View3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_View3.Merge(m, src)
}
func (m *View3) XXX_Size() int {
	return m.Size()
}
func (m *View3) XXX_DiscardUnknown() {
	xxx_messageInfo_View3.DiscardUnknown(m)
}

var xxx_messageInfo_View3 proto.InternalMessageInfo

type Page3 struct {
	Cid                  int64     `protobuf:"varint,1,opt,name=Cid,proto3" json:"cid"`
	Page                 int32     `protobuf:"varint,2,opt,name=Page,proto3" json:"page"`
	From                 string    `protobuf:"bytes,3,opt,name=From,proto3" json:"from"`
	Part                 string    `protobuf:"bytes,4,opt,name=Part,proto3" json:"part"`
	Duration             int64     `protobuf:"varint,5,opt,name=Duration,proto3" json:"duration"`
	Vid                  string    `protobuf:"bytes,6,opt,name=Vid,proto3" json:"vid"`
	Desc                 string    `protobuf:"bytes,7,opt,name=Desc,proto3" json:"description,omitempty"`
	WebLink              string    `protobuf:"bytes,8,opt,name=WebLink,proto3" json:"weblink"`
	Dimension            Dimension `protobuf:"bytes,9,opt,name=Dimension,proto3" json:"dimension"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Page3) Reset()         { *m = Page3{} }
func (m *Page3) String() string { return proto.CompactTextString(m) }
func (*Page3) ProtoMessage()    {}
func (*Page3) Descriptor() ([]byte, []int) {
	return fileDescriptor_4d6cd72ef61298a2, []int{9}
}
func (m *Page3) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Page3) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Page3.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Page3) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Page3.Merge(m, src)
}
func (m *Page3) XXX_Size() int {
	return m.Size()
}
func (m *Page3) XXX_DiscardUnknown() {
	xxx_messageInfo_Page3.DiscardUnknown(m)
}

var xxx_messageInfo_Page3 proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Archive3)(nil), "archive.Archive3")
	proto.RegisterType((*StaffInfo)(nil), "archive.StaffInfo")
	proto.RegisterType((*Dimension)(nil), "archive.Dimension")
	proto.RegisterType((*Rights3)(nil), "archive.Rights3")
	proto.RegisterType((*Author3)(nil), "archive.Author3")
	proto.RegisterType((*Stat3)(nil), "archive.Stat3")
	proto.RegisterType((*Click3)(nil), "archive.Click3")
	proto.RegisterType((*AidVideos3)(nil), "archive.AidVideos3")
	proto.RegisterType((*View3)(nil), "archive.View3")
	proto.RegisterType((*Page3)(nil), "archive.Page3")
}

func init() {
	proto.RegisterFile("app/service/main/archive/model/archive/archive.proto", fileDescriptor_4d6cd72ef61298a2)
}

var fileDescriptor_4d6cd72ef61298a2 = []byte{
	// 1539 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x57, 0xdd, 0x4e, 0x1b, 0x49,
	0x16, 0xc6, 0xff, 0x76, 0xf1, 0x93, 0x50, 0x10, 0x68, 0x02, 0xa2, 0x91, 0x57, 0x89, 0xd0, 0x6e,
	0xc0, 0x51, 0x58, 0x36, 0x59, 0x69, 0xb5, 0x2b, 0xff, 0x2c, 0x01, 0x29, 0x24, 0x51, 0x85, 0x90,
	0xbd, 0x63, 0xcb, 0xdd, 0x85, 0x5d, 0xc2, 0xdd, 0xd5, 0xaa, 0x2e, 0xdb, 0xf2, 0x3b, 0xcd, 0x23,
	0xcc, 0x03, 0xe4, 0x32, 0x0f, 0x30, 0x6a, 0x4d, 0x72, 0xd9, 0x2f, 0x30, 0xd2, 0x68, 0x2e, 0x46,
	0x75, 0xaa, 0x6c, 0xb7, 0x47, 0x33, 0xcc, 0x15, 0xee, 0xef, 0xfb, 0x4e, 0xd5, 0x39, 0x55, 0x75,
	0x7e, 0x40, 0x7f, 0xa7, 0x51, 0xd4, 0x88, 0x99, 0x1c, 0x71, 0x8f, 0x35, 0x02, 0xca, 0xc3, 0x06,
	0x95, 0x5e, 0x9f, 0x8f, 0x58, 0x23, 0x10, 0x3e, 0x1b, 0xcc, 0xbe, 0xec, 0xdf, 0xe3, 0x48, 0x0a,
	0x25, 0x70, 0xc5, 0x7e, 0x3e, 0x3e, 0xea, 0x71, 0xd5, 0x1f, 0x76, 0x8f, 0x3d, 0x11, 0x34, 0x7a,
	0xa2, 0x27, 0x1a, 0xc0, 0x77, 0x87, 0xb7, 0xf0, 0x05, 0x1f, 0xf0, 0xcb, 0xd8, 0xd5, 0xbf, 0x43,
	0xa8, 0xda, 0x34, 0xa6, 0x27, 0x78, 0x07, 0x15, 0x9a, 0xdc, 0x77, 0x72, 0x07, 0xb9, 0xc3, 0x42,
	0xab, 0x92, 0x26, 0x6e, 0x81, 0x72, 0x9f, 0x68, 0x0c, 0xd7, 0x51, 0xf9, 0x9a, 0xfb, 0x4c, 0xc4,
	0x4e, 0x1e, 0x58, 0x94, 0x26, 0x6e, 0x79, 0x04, 0x08, 0xb1, 0x0c, 0x76, 0x51, 0xf9, 0x6a, 0x12,
	0xb1, 0x8b, 0x8e, 0x53, 0x38, 0xc8, 0x1d, 0x96, 0xcc, 0x0a, 0x8a, 0xfb, 0xc4, 0xc2, 0xf8, 0x09,
	0xaa, 0xea, 0x5f, 0x6f, 0x69, 0xc0, 0x9c, 0xe2, 0x41, 0xee, 0xb0, 0xd6, 0xaa, 0xa5, 0x89, 0x5b,
	0x52, 0x21, 0x0d, 0x18, 0x99, 0x51, 0xf8, 0x6f, 0xa8, 0xd6, 0x16, 0xd1, 0x44, 0xf2, 0x5e, 0x5f,
	0x39, 0x25, 0x58, 0x6a, 0x35, 0x4d, 0xdc, 0x9a, 0x37, 0x05, 0xc9, 0x9c, 0xd7, 0x3e, 0xbf, 0xe7,
	0x9e, 0x53, 0x86, 0xe5, 0x60, 0xc7, 0x88, 0x7b, 0x44, 0x63, 0xd8, 0x45, 0xa5, 0x2b, 0xae, 0x06,
	0xcc, 0xa9, 0x64, 0xf6, 0xd2, 0x00, 0x31, 0x38, 0xee, 0xa0, 0xca, 0xfb, 0x61, 0xb7, 0x43, 0x15,
	0x73, 0xaa, 0x10, 0xd5, 0x5f, 0xd3, 0xc4, 0xad, 0x44, 0xc3, 0xae, 0x4f, 0x15, 0xfb, 0x39, 0x71,
	0x77, 0x7b, 0xe2, 0xc8, 0x13, 0x41, 0x20, 0xc2, 0xc6, 0x80, 0x77, 0x25, 0x95, 0x93, 0x86, 0xe2,
	0x01, 0x3b, 0xbe, 0xe2, 0x01, 0x23, 0x53, 0x53, 0xfc, 0x6f, 0x54, 0x6a, 0x6b, 0xd8, 0xa9, 0xc1,
	0x1a, 0x87, 0x7a, 0x1b, 0x4f, 0x03, 0x7f, 0xb6, 0x82, 0x31, 0xc3, 0x7b, 0xa8, 0xd8, 0x61, 0xb1,
	0xe7, 0x20, 0xf0, 0xb2, 0x9a, 0x26, 0x6e, 0xd1, 0x67, 0xb1, 0x47, 0x00, 0xd5, 0x41, 0x7c, 0x50,
	0xda, 0xc3, 0x65, 0x38, 0x08, 0x08, 0x22, 0xd6, 0x00, 0x31, 0x38, 0x7e, 0x86, 0xca, 0x4d, 0xcf,
	0x63, 0x71, 0xec, 0xac, 0x80, 0x62, 0x33, 0x4d, 0xdc, 0x87, 0x14, 0x90, 0x67, 0x22, 0xe0, 0x8a,
	0x05, 0x91, 0x9a, 0x10, 0xab, 0xc1, 0xa7, 0xa8, 0xd6, 0x54, 0x4a, 0xf2, 0xee, 0x50, 0x31, 0x67,
	0x15, 0x0c, 0xb6, 0xd3, 0xc4, 0xdd, 0xa0, 0x53, 0x30, 0x63, 0x33, 0x57, 0xe2, 0x6d, 0x54, 0xb8,
	0xa2, 0x3d, 0x67, 0x0d, 0x5c, 0x2c, 0xa5, 0x89, 0x9b, 0x3b, 0x22, 0x1a, 0xc1, 0x4f, 0x51, 0xf1,
	0x8a, 0xf6, 0x62, 0xe7, 0xc1, 0x41, 0xe1, 0xb0, 0xd6, 0xc2, 0x69, 0xe2, 0xae, 0x29, 0xda, 0xcb,
	0xee, 0x0c, 0x3c, 0x3e, 0x44, 0xd5, 0xce, 0x50, 0x52, 0xc5, 0x45, 0xe8, 0x3c, 0x84, 0x73, 0x5a,
	0x49, 0x13, 0xb7, 0xea, 0x5b, 0x8c, 0xcc, 0x58, 0xfc, 0x0f, 0x54, 0xbb, 0xe4, 0x71, 0xcc, 0x45,
	0x78, 0xd1, 0x71, 0xd6, 0x41, 0xea, 0xa4, 0x89, 0xbb, 0x19, 0x18, 0xf0, 0x86, 0xfb, 0x59, 0x17,
	0x67, 0x52, 0xfc, 0x1c, 0x55, 0xde, 0x49, 0x9f, 0xc9, 0x8b, 0x8e, 0x83, 0xc1, 0x6a, 0x2b, 0x4d,
	0x5c, 0x2c, 0x34, 0xb4, 0x68, 0x33, 0x95, 0xe1, 0x7f, 0xa1, 0x65, 0xc2, 0x7c, 0x2e, 0x99, 0xa7,
	0x3e, 0x92, 0x37, 0xce, 0x06, 0x04, 0xf7, 0x38, 0x4d, 0xdc, 0x2d, 0x69, 0xe1, 0x9b, 0xa1, 0x1c,
	0x64, 0x2c, 0xb3, 0x72, 0xdc, 0x40, 0x95, 0x33, 0x21, 0xc7, 0x54, 0xfa, 0xce, 0x26, 0xec, 0xf7,
	0x28, 0x4d, 0xdc, 0xf5, 0x5b, 0x03, 0x65, 0xb7, 0xb3, 0x2a, 0xfc, 0x0a, 0x95, 0x89, 0x7e, 0xb2,
	0xb1, 0xf3, 0xe8, 0x20, 0x77, 0xb8, 0xfc, 0xe2, 0xe1, 0xf1, 0x34, 0x85, 0x0d, 0x7c, 0xd2, 0x5a,
	0xfb, 0x9c, 0xb8, 0x4b, 0x3a, 0xb1, 0xe0, 0x69, 0xc7, 0xc4, 0xea, 0xf1, 0x4b, 0x54, 0x6e, 0x0e,
	0x55, 0x5f, 0x48, 0x67, 0xeb, 0x37, 0x96, 0x06, 0x3e, 0x69, 0xad, 0x5a, 0xcb, 0x92, 0x18, 0x87,
	0x4c, 0x12, 0x2b, 0xc7, 0xcf, 0x51, 0x51, 0x3f, 0x12, 0x67, 0x1b, 0xcc, 0xd6, 0x66, 0x66, 0x1a,
	0x3c, 0x69, 0xad, 0x58, 0xa3, 0xa2, 0x7e, 0x4f, 0x04, 0x94, 0xf8, 0x3f, 0x68, 0x85, 0xb0, 0x48,
	0x48, 0x45, 0x58, 0x3c, 0x1c, 0x28, 0xc7, 0x81, 0x43, 0xd9, 0x4d, 0x13, 0x77, 0x5b, 0x02, 0x7e,
	0x23, 0x81, 0xc8, 0x04, 0xb8, 0x60, 0x80, 0x9f, 0xa0, 0x4a, 0x67, 0x12, 0xd2, 0x80, 0x7b, 0xce,
	0x0e, 0xd8, 0x2e, 0xeb, 0x9c, 0xf2, 0x0d, 0x44, 0xa6, 0x1c, 0x3e, 0x42, 0xd5, 0x33, 0x2e, 0x63,
	0xd5, 0xe6, 0xbe, 0xf3, 0x18, 0x8e, 0x6f, 0x3d, 0x4d, 0xdc, 0x55, 0x6f, 0xe1, 0xa6, 0x66, 0x12,
	0x7c, 0x89, 0x6a, 0x1d, 0x1e, 0xb0, 0x50, 0xdf, 0xb5, 0xb3, 0x0b, 0xd1, 0xe0, 0x59, 0x34, 0x33,
	0xa6, 0xb5, 0x6b, 0x23, 0xda, 0xf0, 0xa7, 0x50, 0xf6, 0xad, 0xcc, 0x74, 0xf8, 0x25, 0xaa, 0x7d,
	0x50, 0xf4, 0xf6, 0xf6, 0x22, 0xbc, 0x15, 0xce, 0xde, 0x41, 0x61, 0x61, 0xb9, 0x19, 0x33, 0x7d,
	0xe8, 0x73, 0x6d, 0xfd, 0x75, 0xc6, 0x50, 0x97, 0x9e, 0xcb, 0xc5, 0x72, 0x19, 0xe8, 0x72, 0x79,
	0xc9, 0xfd, 0x79, 0xe9, 0xc9, 0xff, 0x7e, 0xe9, 0xa9, 0xab, 0x4c, 0x40, 0x5a, 0xfd, 0x89, 0xfb,
	0xaa, 0x6f, 0x97, 0x02, 0xf5, 0x58, 0x03, 0xc4, 0xe0, 0xba, 0xfa, 0x9e, 0x33, 0x28, 0x87, 0x99,
	0xea, 0xdb, 0x07, 0x84, 0x58, 0x46, 0x6b, 0x88, 0x80, 0x4a, 0x51, 0x98, 0x6b, 0x24, 0x20, 0xc4,
	0x32, 0xf5, 0x9f, 0xf2, 0xa8, 0x62, 0x1f, 0x1b, 0xde, 0x42, 0xf9, 0x56, 0x04, 0x3b, 0x96, 0x5a,
	0xe5, 0x34, 0x71, 0xf3, 0xdd, 0x88, 0xe4, 0x5b, 0x91, 0x2e, 0x47, 0xff, 0x1d, 0x30, 0x0f, 0x76,
	0x2a, 0x99, 0x72, 0xc4, 0x06, 0xcc, 0x23, 0x80, 0x42, 0x1e, 0x8b, 0x71, 0x38, 0x10, 0xd4, 0xb7,
	0x55, 0xde, 0xe4, 0xb1, 0xc5, 0xc8, 0x8c, 0xd5, 0x41, 0x5d, 0x8a, 0x11, 0x37, 0x95, 0xde, 0x16,
	0xae, 0x40, 0x03, 0xc4, 0xe0, 0x50, 0xb9, 0xe9, 0xc4, 0x16, 0x78, 0x53, 0xb9, 0xe9, 0x84, 0x68,
	0x4c, 0x53, 0xe7, 0x9d, 0x53, 0x28, 0xea, 0x96, 0xea, 0xfb, 0xa7, 0x44, 0x63, 0xf8, 0x19, 0xaa,
	0xbd, 0x15, 0x84, 0x45, 0x92, 0x87, 0x0a, 0x0a, 0x7b, 0xa9, 0xb5, 0x96, 0x26, 0x2e, 0x0a, 0xc5,
	0x8d, 0x34, 0x28, 0x99, 0x0b, 0xb4, 0xbb, 0xcd, 0xa1, 0x12, 0xd1, 0x80, 0x4e, 0xa0, 0xc4, 0x5b,
	0x77, 0xa9, 0xc5, 0xc8, 0x8c, 0xc5, 0x7f, 0x41, 0xe5, 0x8f, 0xaf, 0xdb, 0xda, 0xa1, 0x1a, 0xe8,
	0xe0, 0xd9, 0x0e, 0x7b, 0xde, 0x8d, 0x76, 0xca, 0x52, 0xf8, 0x15, 0x5a, 0xbd, 0x88, 0xdb, 0x42,
	0x44, 0xcc, 0x96, 0x32, 0x04, 0x5a, 0x28, 0x7b, 0x3c, 0xbe, 0xf1, 0xe6, 0x0c, 0x59, 0x14, 0xd6,
	0xff, 0x8f, 0x2a, 0x36, 0x57, 0xef, 0x7b, 0x36, 0x7b, 0xa8, 0x08, 0xcd, 0x31, 0x3f, 0x6f, 0x05,
	0xd0, 0x1b, 0x01, 0xd5, 0xec, 0x19, 0xf5, 0xcc, 0xfd, 0x5a, 0xf6, 0x96, 0x7a, 0x8c, 0x00, 0x5a,
	0xff, 0x25, 0x6f, 0x3a, 0xc5, 0xbd, 0x6d, 0x7c, 0x0f, 0x15, 0xaf, 0x39, 0x1b, 0x67, 0x2f, 0x77,
	0xc4, 0xd9, 0x98, 0x00, 0x0a, 0xb9, 0x4b, 0xc3, 0x80, 0xde, 0x0d, 0xed, 0xdd, 0x9a, 0xdc, 0x35,
	0x10, 0x99, 0x72, 0xfa, 0x66, 0x09, 0x8b, 0x06, 0x93, 0xec, 0xcd, 0x4a, 0x0d, 0x10, 0x83, 0xe3,
	0x7d, 0x54, 0x38, 0xa3, 0x23, 0x7b, 0xb3, 0x70, 0xe0, 0xb7, 0x74, 0x24, 0x24, 0x57, 0x8c, 0x68,
	0x42, 0x7b, 0xd1, 0x16, 0x3c, 0xb4, 0xf7, 0x0b, 0x5e, 0x78, 0x82, 0x87, 0x04, 0x50, 0xe8, 0x78,
	0x7d, 0x2a, 0x99, 0xbd, 0x5d, 0xd3, 0xf1, 0x34, 0x40, 0x0c, 0x8e, 0x9f, 0xa2, 0xca, 0x5b, 0x31,
	0x26, 0x34, 0xbc, 0xcb, 0xde, 0x69, 0x28, 0xc6, 0x37, 0x92, 0x86, 0x77, 0x64, 0x4a, 0x6a, 0xdd,
	0x39, 0x8f, 0x41, 0x57, 0x9b, 0xeb, 0xfa, 0x3c, 0xb6, 0x3a, 0x4b, 0x6a, 0x77, 0xde, 0xf0, 0x3b,
	0x66, 0x2f, 0x13, 0xdc, 0x19, 0xf0, 0x3b, 0x46, 0x00, 0x85, 0x43, 0xe1, 0x31, 0x08, 0x96, 0x33,
	0x87, 0xc2, 0x63, 0xd0, 0x4c, 0xb9, 0xfa, 0xf7, 0x39, 0x54, 0x6e, 0x0f, 0xb8, 0x77, 0x77, 0xef,
	0xf9, 0xef, 0xa0, 0xc2, 0x27, 0xd6, 0xb5, 0xc7, 0x0f, 0xd4, 0x98, 0x75, 0x89, 0xc6, 0x34, 0x75,
	0x21, 0xe2, 0xec, 0xe8, 0xc4, 0x45, 0x4c, 0x34, 0xa6, 0x5d, 0x68, 0x86, 0xbe, 0x14, 0xdc, 0xb7,
	0x47, 0x0e, 0x2e, 0x50, 0x03, 0x91, 0x29, 0xa7, 0x33, 0xfa, 0xfc, 0xd4, 0x9e, 0x3a, 0x64, 0x74,
	0xff, 0x94, 0xe4, 0xcf, 0x4f, 0x75, 0x65, 0x78, 0x37, 0x54, 0x8a, 0x49, 0x7b, 0xe0, 0x50, 0x19,
	0x04, 0x20, 0xc4, 0x32, 0xf5, 0xff, 0x21, 0xd4, 0xe4, 0xbe, 0x19, 0xe4, 0xee, 0x8d, 0xa0, 0x81,
	0x4a, 0xef, 0x69, 0x8f, 0xe9, 0x39, 0xb0, 0xb0, 0xd0, 0x53, 0x34, 0x7a, 0x62, 0x6e, 0x2b, 0xd2,
	0x02, 0x62, 0x74, 0xf5, 0x09, 0x2a, 0xe9, 0xc7, 0x75, 0x82, 0x4f, 0x51, 0xc5, 0x4e, 0x9a, 0xb0,
	0xf0, 0xf2, 0x8b, 0xf5, 0x79, 0x1b, 0xb3, 0x13, 0x68, 0xab, 0xfa, 0x25, 0x71, 0x73, 0x69, 0xe2,
	0x2e, 0x91, 0xa9, 0x16, 0xff, 0xf3, 0xfe, 0x0d, 0x37, 0xd2, 0xc4, 0x7d, 0x00, 0x1b, 0x66, 0x4a,
	0xbd, 0xdd, 0xfa, 0x87, 0xbc, 0xb1, 0x85, 0x80, 0xda, 0x8b, 0x01, 0x79, 0x3a, 0xa0, 0xb6, 0x49,
	0x09, 0xad, 0xc9, 0xa6, 0x84, 0x5e, 0x8e, 0x00, 0x0a, 0x39, 0x27, 0x45, 0xb0, 0x90, 0x73, 0x52,
	0x04, 0x04, 0x50, 0x63, 0x2b, 0x95, 0x1d, 0x66, 0xad, 0xad, 0x54, 0x04, 0xd0, 0x85, 0x99, 0xa7,
	0x74, 0xef, 0xcc, 0xb3, 0x83, 0x0a, 0xd7, 0xdc, 0xcf, 0x0e, 0xb1, 0x23, 0xed, 0xde, 0x35, 0xf7,
	0xf1, 0x91, 0x9d, 0x0e, 0xcd, 0x0c, 0xbb, 0x93, 0x26, 0xee, 0x23, 0x3d, 0x1d, 0x4a, 0x1e, 0xa9,
	0xc5, 0xf6, 0x66, 0xc6, 0xc5, 0x27, 0xa8, 0xf2, 0x89, 0x75, 0xdf, 0x70, 0x9b, 0x1b, 0xb6, 0xfd,
	0x8e, 0x59, 0x77, 0xc0, 0xf5, 0x93, 0xb7, 0x1c, 0x6e, 0x67, 0xfb, 0x69, 0xed, 0x0f, 0xfb, 0xe9,
	0xba, 0xed, 0xa7, 0xb5, 0x59, 0x3f, 0xcd, 0x74, 0xd1, 0xd6, 0xe6, 0xe7, 0xaf, 0xfb, 0x4b, 0x5f,
	0xbe, 0xee, 0x2f, 0x7d, 0xfe, 0xb6, 0x9f, 0xfb, 0xf2, 0x6d, 0x3f, 0xf7, 0xe3, 0xb7, 0xfd, 0x5c,
	0xb7, 0x0c, 0xff, 0x58, 0x9c, 0xfc, 0x1a, 0x00, 0x00, 0xff, 0xff, 0xd3, 0x19, 0x81, 0xcb, 0xc8,
	0x0c, 0x00, 0x00,
}

func (m *Archive3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Archive3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Archive3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StaffInfo) > 0 {
		for iNdEx := len(m.StaffInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StaffInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintArchive(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xe2
		}
	}
	{
		size, err := m.Dimension.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintArchive(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xda
	if m.FirstCid != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.FirstCid))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if len(m.Dynamic) > 0 {
		i -= len(m.Dynamic)
		copy(dAtA[i:], m.Dynamic)
		i = encodeVarintArchive(dAtA, i, uint64(len(m.Dynamic)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.ReportResult) > 0 {
		i -= len(m.ReportResult)
		copy(dAtA[i:], m.ReportResult)
		i = encodeVarintArchive(dAtA, i, uint64(len(m.ReportResult)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	{
		size, err := m.Stat.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintArchive(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xba
	{
		size, err := m.Author.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintArchive(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb2
	{
		size, err := m.Rights.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintArchive(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xaa
	if m.Forward != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Forward))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if len(m.RedirectURL) > 0 {
		i -= len(m.RedirectURL)
		copy(dAtA[i:], m.RedirectURL)
		i = encodeVarintArchive(dAtA, i, uint64(len(m.RedirectURL)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.OrderID != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.OrderID))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.MissionID != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.MissionID))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.Duration != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Duration))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tags[iNdEx])
			copy(dAtA[i:], m.Tags[iNdEx])
			i = encodeVarintArchive(dAtA, i, uint64(len(m.Tags[iNdEx])))
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.Tag) > 0 {
		i -= len(m.Tag)
		copy(dAtA[i:], m.Tag)
		i = encodeVarintArchive(dAtA, i, uint64(len(m.Tag)))
		i--
		dAtA[i] = 0x72
	}
	if m.Attribute != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Attribute))
		i--
		dAtA[i] = 0x68
	}
	if m.Access != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Access))
		i--
		dAtA[i] = 0x60
	}
	if m.State != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x58
	}
	if len(m.Desc) > 0 {
		i -= len(m.Desc)
		copy(dAtA[i:], m.Desc)
		i = encodeVarintArchive(dAtA, i, uint64(len(m.Desc)))
		i--
		dAtA[i] = 0x52
	}
	if m.Ctime != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Ctime))
		i--
		dAtA[i] = 0x48
	}
	if m.PubDate != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.PubDate))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintArchive(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Pic) > 0 {
		i -= len(m.Pic)
		copy(dAtA[i:], m.Pic)
		i = encodeVarintArchive(dAtA, i, uint64(len(m.Pic)))
		i--
		dAtA[i] = 0x32
	}
	if m.Copyright != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Copyright))
		i--
		dAtA[i] = 0x28
	}
	if len(m.TypeName) > 0 {
		i -= len(m.TypeName)
		copy(dAtA[i:], m.TypeName)
		i = encodeVarintArchive(dAtA, i, uint64(len(m.TypeName)))
		i--
		dAtA[i] = 0x22
	}
	if m.TypeID != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x18
	}
	if m.Videos != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Videos))
		i--
		dAtA[i] = 0x10
	}
	if m.Aid != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Aid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StaffInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StaffInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StaffInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintArchive(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x12
	}
	if m.Mid != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Dimension) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dimension) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Dimension) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Rotate != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Rotate))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.Width != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Rights3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rights3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Rights3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsCooperation != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.IsCooperation))
		i--
		dAtA[i] = 0x50
	}
	if m.UGCPay != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.UGCPay))
		i--
		dAtA[i] = 0x48
	}
	if m.Autoplay != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Autoplay))
		i--
		dAtA[i] = 0x40
	}
	if m.NoReprint != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.NoReprint))
		i--
		dAtA[i] = 0x38
	}
	if m.HD5 != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.HD5))
		i--
		dAtA[i] = 0x30
	}
	if m.Pay != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Pay))
		i--
		dAtA[i] = 0x28
	}
	if m.Movie != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Movie))
		i--
		dAtA[i] = 0x20
	}
	if m.Download != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Download))
		i--
		dAtA[i] = 0x18
	}
	if m.Elec != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Elec))
		i--
		dAtA[i] = 0x10
	}
	if m.Bp != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Bp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Author3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Author3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Author3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Face) > 0 {
		i -= len(m.Face)
		copy(dAtA[i:], m.Face)
		i = encodeVarintArchive(dAtA, i, uint64(len(m.Face)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintArchive(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Mid != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Mid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Stat3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Stat3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Stat3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DisLike != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.DisLike))
		i--
		dAtA[i] = 0x58
	}
	if m.Like != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Like))
		i--
		dAtA[i] = 0x50
	}
	if m.HisRank != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.HisRank))
		i--
		dAtA[i] = 0x48
	}
	if m.NowRank != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.NowRank))
		i--
		dAtA[i] = 0x40
	}
	if m.Share != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Share))
		i--
		dAtA[i] = 0x38
	}
	if m.Coin != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Coin))
		i--
		dAtA[i] = 0x30
	}
	if m.Fav != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Fav))
		i--
		dAtA[i] = 0x28
	}
	if m.Reply != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Reply))
		i--
		dAtA[i] = 0x20
	}
	if m.Danmaku != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Danmaku))
		i--
		dAtA[i] = 0x18
	}
	if m.View != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.View))
		i--
		dAtA[i] = 0x10
	}
	if m.Aid != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Aid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Click3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Click3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Click3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Outter != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Outter))
		i--
		dAtA[i] = 0x30
	}
	if m.H5 != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.H5))
		i--
		dAtA[i] = 0x28
	}
	if m.Android != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Android))
		i--
		dAtA[i] = 0x20
	}
	if m.Ios != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Ios))
		i--
		dAtA[i] = 0x18
	}
	if m.Web != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Web))
		i--
		dAtA[i] = 0x10
	}
	if m.Aid != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Aid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AidVideos3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AidVideos3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AidVideos3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Pages) > 0 {
		for iNdEx := len(m.Pages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintArchive(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Aid != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Aid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *View3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *View3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *View3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Pages) > 0 {
		for iNdEx := len(m.Pages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Pages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintArchive(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Archive3 != nil {
		{
			size, err := m.Archive3.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintArchive(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Page3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Page3) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Page3) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Dimension.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintArchive(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if len(m.WebLink) > 0 {
		i -= len(m.WebLink)
		copy(dAtA[i:], m.WebLink)
		i = encodeVarintArchive(dAtA, i, uint64(len(m.WebLink)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Desc) > 0 {
		i -= len(m.Desc)
		copy(dAtA[i:], m.Desc)
		i = encodeVarintArchive(dAtA, i, uint64(len(m.Desc)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Vid) > 0 {
		i -= len(m.Vid)
		copy(dAtA[i:], m.Vid)
		i = encodeVarintArchive(dAtA, i, uint64(len(m.Vid)))
		i--
		dAtA[i] = 0x32
	}
	if m.Duration != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Duration))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Part) > 0 {
		i -= len(m.Part)
		copy(dAtA[i:], m.Part)
		i = encodeVarintArchive(dAtA, i, uint64(len(m.Part)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintArchive(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Page != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x10
	}
	if m.Cid != 0 {
		i = encodeVarintArchive(dAtA, i, uint64(m.Cid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintArchive(dAtA []byte, offset int, v uint64) int {
	offset -= sovArchive(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Archive3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovArchive(uint64(m.Aid))
	}
	if m.Videos != 0 {
		n += 1 + sovArchive(uint64(m.Videos))
	}
	if m.TypeID != 0 {
		n += 1 + sovArchive(uint64(m.TypeID))
	}
	l = len(m.TypeName)
	if l > 0 {
		n += 1 + l + sovArchive(uint64(l))
	}
	if m.Copyright != 0 {
		n += 1 + sovArchive(uint64(m.Copyright))
	}
	l = len(m.Pic)
	if l > 0 {
		n += 1 + l + sovArchive(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovArchive(uint64(l))
	}
	if m.PubDate != 0 {
		n += 1 + sovArchive(uint64(m.PubDate))
	}
	if m.Ctime != 0 {
		n += 1 + sovArchive(uint64(m.Ctime))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovArchive(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovArchive(uint64(m.State))
	}
	if m.Access != 0 {
		n += 1 + sovArchive(uint64(m.Access))
	}
	if m.Attribute != 0 {
		n += 1 + sovArchive(uint64(m.Attribute))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovArchive(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovArchive(uint64(l))
		}
	}
	if m.Duration != 0 {
		n += 2 + sovArchive(uint64(m.Duration))
	}
	if m.MissionID != 0 {
		n += 2 + sovArchive(uint64(m.MissionID))
	}
	if m.OrderID != 0 {
		n += 2 + sovArchive(uint64(m.OrderID))
	}
	l = len(m.RedirectURL)
	if l > 0 {
		n += 2 + l + sovArchive(uint64(l))
	}
	if m.Forward != 0 {
		n += 2 + sovArchive(uint64(m.Forward))
	}
	l = m.Rights.Size()
	n += 2 + l + sovArchive(uint64(l))
	l = m.Author.Size()
	n += 2 + l + sovArchive(uint64(l))
	l = m.Stat.Size()
	n += 2 + l + sovArchive(uint64(l))
	l = len(m.ReportResult)
	if l > 0 {
		n += 2 + l + sovArchive(uint64(l))
	}
	l = len(m.Dynamic)
	if l > 0 {
		n += 2 + l + sovArchive(uint64(l))
	}
	if m.FirstCid != 0 {
		n += 2 + sovArchive(uint64(m.FirstCid))
	}
	l = m.Dimension.Size()
	n += 2 + l + sovArchive(uint64(l))
	if len(m.StaffInfo) > 0 {
		for _, e := range m.StaffInfo {
			l = e.Size()
			n += 2 + l + sovArchive(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StaffInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovArchive(uint64(m.Mid))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovArchive(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Dimension) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Width != 0 {
		n += 1 + sovArchive(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovArchive(uint64(m.Height))
	}
	if m.Rotate != 0 {
		n += 1 + sovArchive(uint64(m.Rotate))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Rights3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Bp != 0 {
		n += 1 + sovArchive(uint64(m.Bp))
	}
	if m.Elec != 0 {
		n += 1 + sovArchive(uint64(m.Elec))
	}
	if m.Download != 0 {
		n += 1 + sovArchive(uint64(m.Download))
	}
	if m.Movie != 0 {
		n += 1 + sovArchive(uint64(m.Movie))
	}
	if m.Pay != 0 {
		n += 1 + sovArchive(uint64(m.Pay))
	}
	if m.HD5 != 0 {
		n += 1 + sovArchive(uint64(m.HD5))
	}
	if m.NoReprint != 0 {
		n += 1 + sovArchive(uint64(m.NoReprint))
	}
	if m.Autoplay != 0 {
		n += 1 + sovArchive(uint64(m.Autoplay))
	}
	if m.UGCPay != 0 {
		n += 1 + sovArchive(uint64(m.UGCPay))
	}
	if m.IsCooperation != 0 {
		n += 1 + sovArchive(uint64(m.IsCooperation))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Author3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mid != 0 {
		n += 1 + sovArchive(uint64(m.Mid))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovArchive(uint64(l))
	}
	l = len(m.Face)
	if l > 0 {
		n += 1 + l + sovArchive(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Stat3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovArchive(uint64(m.Aid))
	}
	if m.View != 0 {
		n += 1 + sovArchive(uint64(m.View))
	}
	if m.Danmaku != 0 {
		n += 1 + sovArchive(uint64(m.Danmaku))
	}
	if m.Reply != 0 {
		n += 1 + sovArchive(uint64(m.Reply))
	}
	if m.Fav != 0 {
		n += 1 + sovArchive(uint64(m.Fav))
	}
	if m.Coin != 0 {
		n += 1 + sovArchive(uint64(m.Coin))
	}
	if m.Share != 0 {
		n += 1 + sovArchive(uint64(m.Share))
	}
	if m.NowRank != 0 {
		n += 1 + sovArchive(uint64(m.NowRank))
	}
	if m.HisRank != 0 {
		n += 1 + sovArchive(uint64(m.HisRank))
	}
	if m.Like != 0 {
		n += 1 + sovArchive(uint64(m.Like))
	}
	if m.DisLike != 0 {
		n += 1 + sovArchive(uint64(m.DisLike))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Click3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovArchive(uint64(m.Aid))
	}
	if m.Web != 0 {
		n += 1 + sovArchive(uint64(m.Web))
	}
	if m.Ios != 0 {
		n += 1 + sovArchive(uint64(m.Ios))
	}
	if m.Android != 0 {
		n += 1 + sovArchive(uint64(m.Android))
	}
	if m.H5 != 0 {
		n += 1 + sovArchive(uint64(m.H5))
	}
	if m.Outter != 0 {
		n += 1 + sovArchive(uint64(m.Outter))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AidVideos3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Aid != 0 {
		n += 1 + sovArchive(uint64(m.Aid))
	}
	if len(m.Pages) > 0 {
		for _, e := range m.Pages {
			l = e.Size()
			n += 1 + l + sovArchive(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *View3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Archive3 != nil {
		l = m.Archive3.Size()
		n += 1 + l + sovArchive(uint64(l))
	}
	if len(m.Pages) > 0 {
		for _, e := range m.Pages {
			l = e.Size()
			n += 1 + l + sovArchive(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Page3) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cid != 0 {
		n += 1 + sovArchive(uint64(m.Cid))
	}
	if m.Page != 0 {
		n += 1 + sovArchive(uint64(m.Page))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovArchive(uint64(l))
	}
	l = len(m.Part)
	if l > 0 {
		n += 1 + l + sovArchive(uint64(l))
	}
	if m.Duration != 0 {
		n += 1 + sovArchive(uint64(m.Duration))
	}
	l = len(m.Vid)
	if l > 0 {
		n += 1 + l + sovArchive(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovArchive(uint64(l))
	}
	l = len(m.WebLink)
	if l > 0 {
		n += 1 + l + sovArchive(uint64(l))
	}
	l = m.Dimension.Size()
	n += 1 + l + sovArchive(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovArchive(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozArchive(x uint64) (n int) {
	return sovArchive(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Archive3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Archive3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Archive3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Videos", wireType)
			}
			m.Videos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Videos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TypeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Copyright", wireType)
			}
			m.Copyright = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Copyright |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubDate", wireType)
			}
			m.PubDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PubDate |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctime", wireType)
			}
			m.Ctime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ctime |= go_common_library_time.Time(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Access", wireType)
			}
			m.Access = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Access |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attribute", wireType)
			}
			m.Attribute = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Attribute |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissionID", wireType)
			}
			m.MissionID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MissionID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderID", wireType)
			}
			m.OrderID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OrderID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RedirectURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Forward", wireType)
			}
			m.Forward = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Forward |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rights", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArchive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Rights.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArchive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Author.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArchive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportResult", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportResult = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dynamic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dynamic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstCid", wireType)
			}
			m.FirstCid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FirstCid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dimension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArchive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Dimension.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StaffInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArchive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StaffInfo = append(m.StaffInfo, &StaffInfo{})
			if err := m.StaffInfo[len(m.StaffInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArchive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArchive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StaffInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StaffInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StaffInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArchive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArchive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dimension) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dimension: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dimension: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotate", wireType)
			}
			m.Rotate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rotate |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArchive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArchive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rights3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rights3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rights3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bp", wireType)
			}
			m.Bp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Elec", wireType)
			}
			m.Elec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Elec |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Download", wireType)
			}
			m.Download = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Download |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Movie", wireType)
			}
			m.Movie = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Movie |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pay", wireType)
			}
			m.Pay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pay |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HD5", wireType)
			}
			m.HD5 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HD5 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoReprint", wireType)
			}
			m.NoReprint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NoReprint |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Autoplay", wireType)
			}
			m.Autoplay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Autoplay |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UGCPay", wireType)
			}
			m.UGCPay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UGCPay |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCooperation", wireType)
			}
			m.IsCooperation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsCooperation |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArchive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArchive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Author3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Author3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Author3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Face", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Face = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArchive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArchive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Stat3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stat3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stat3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Danmaku", wireType)
			}
			m.Danmaku = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Danmaku |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reply", wireType)
			}
			m.Reply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reply |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fav", wireType)
			}
			m.Fav = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fav |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Share", wireType)
			}
			m.Share = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Share |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NowRank", wireType)
			}
			m.NowRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NowRank |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HisRank", wireType)
			}
			m.HisRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HisRank |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Like", wireType)
			}
			m.Like = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Like |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisLike", wireType)
			}
			m.DisLike = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DisLike |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArchive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArchive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Click3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Click3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Click3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Web", wireType)
			}
			m.Web = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Web |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ios", wireType)
			}
			m.Ios = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ios |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Android", wireType)
			}
			m.Android = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Android |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field H5", wireType)
			}
			m.H5 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.H5 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outter", wireType)
			}
			m.Outter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Outter |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArchive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArchive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AidVideos3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AidVideos3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AidVideos3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aid", wireType)
			}
			m.Aid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Aid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArchive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pages = append(m.Pages, &Page3{})
			if err := m.Pages[len(m.Pages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArchive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArchive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *View3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: View3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: View3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Archive3", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArchive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Archive3 == nil {
				m.Archive3 = &Archive3{}
			}
			if err := m.Archive3.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArchive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pages = append(m.Pages, &Page3{})
			if err := m.Pages[len(m.Pages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArchive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArchive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Page3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArchive
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Page3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Page3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cid", wireType)
			}
			m.Cid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Part", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Part = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WebLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArchive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WebLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dimension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArchive
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArchive
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Dimension.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArchive(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArchive
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipArchive(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowArchive
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowArchive
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthArchive
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupArchive
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthArchive
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthArchive        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowArchive          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupArchive = fmt.Errorf("proto: unexpected end of group")
)
